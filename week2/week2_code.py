# -*- coding: utf-8 -*-
"""week2_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mJD-j4ZQ_10p4rWcsi1lQT97KAAyA7d6

Consider approximating the Runge function. Let $N+1$ be the number of nodes.

1. Using cubic spline interpolation, find $N$ such that the error of approximation is less than $10^{-10}$.
"""

import numpy as np
from scipy.interpolate import CubicSpline

# Runge function
def f(x):
    return 1/(1+x**2)

# domain
a, b = -5, 5
x_test = np.linspace(a, b, 2001)  # fine grid for error test
y_true = f(x_test)

tol = 1e-10
N = 2  # start with 3 nodes

while True:
    x_nodes = np.linspace(a, b, N+1)  # uniform nodes
    y_nodes = f(x_nodes)

    # cubic spline
    spline = CubicSpline(x_nodes, y_nodes)
    y_approx = spline(x_test)

    err = np.max(np.abs(y_true - y_approx))

    if err < tol:
        print(f"Cubic spline interpolation: N = {N}, error = {err:.2e}")
        break
    N += 1

"""2. Using Chebyshev nodes, find $N$ such that the error of approximation is less than $10^{-10}$."""

import numpy as np
from scipy.interpolate import BarycentricInterpolator

# Runge function
def f(x):
    return 1/(1+x**2)

# domain
a, b = -5, 5
x_test = np.linspace(a, b, 2001)
y_true = f(x_test)

tol = 1e-10
N = 2  # start with 3 nodes

while True:
    # Chebyshev nodes of the second kind, scaled to [a,b]
    k = np.arange(N+1)
    x_nodes = np.cos(np.pi * k / N)   # in [-1,1]
    x_nodes = 0.5*(a+b) + 0.5*(b-a)*x_nodes  # scale to [a,b]
    y_nodes = f(x_nodes)

    # barycentric interpolation (stable)
    interpolant = BarycentricInterpolator(x_nodes, y_nodes)
    y_approx = interpolant(x_test)

    err = np.max(np.abs(y_true - y_approx))

    if err < tol:
        print(f"Chebyshev barycentric interpolation: N = {N}, error = {err:.2e}")
        break
    N += 1